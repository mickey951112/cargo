use crate::core::compiler::RustcTargetData;
use crate::core::resolver::{HasDevUnits, ResolveOpts};
use crate::core::{Shell, Workspace};
use crate::ops;
use crate::util::CargoResult;
use serde::{Deserialize, Serialize};
use serde_json::{from_str, to_writer};
use std::collections::HashMap;
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Strongly typed options for the `cargo doc` command.
#[derive(Debug)]
pub struct DocOptions {
    /// Whether to attempt to open the browser after compiling the docs
    pub open_result: bool,
    /// Options to pass through to the compiler
    pub compile_opts: ops::CompileOptions,
}

/// Main method for `cargo doc`.
pub fn doc(ws: &Workspace<'_>, options: &DocOptions) -> CargoResult<()> {
    let specs = options.compile_opts.spec.to_package_id_specs(ws)?;
    let opts = ResolveOpts::new(
        /*dev_deps*/ true,
        &options.compile_opts.features,
        options.compile_opts.all_features,
        !options.compile_opts.no_default_features,
    );
    let target_data = RustcTargetData::new(ws, &options.compile_opts.build_config.requested_kinds)?;
    let ws_resolve = ops::resolve_ws_with_opts(
        ws,
        &target_data,
        &options.compile_opts.build_config.requested_kinds,
        &opts,
        &specs,
        HasDevUnits::No,
        crate::core::resolver::features::ForceAllTargets::No,
    )?;

    let ids = ws_resolve.targeted_resolve.specs_to_ids(&specs)?;
    let pkgs = ws_resolve.pkg_set.get_many(ids)?;

    let mut lib_names = HashMap::new();
    let mut bin_names = HashMap::new();
    let mut names = Vec::new();
    for package in &pkgs {
        for target in package.targets().iter().filter(|t| t.documented()) {
            if target.is_lib() {
                if let Some(prev) = lib_names.insert(target.crate_name(), package) {
                    anyhow::bail!(
                        "The library `{}` is specified by packages `{}` and \
                         `{}` but can only be documented once. Consider renaming \
                         or marking one of the targets as `doc = false`.",
                        target.crate_name(),
                        prev,
                        package
                    );
                }
            } else if let Some(prev) = bin_names.insert(target.crate_name(), package) {
                anyhow::bail!(
                    "The binary `{}` is specified by packages `{}` and \
                     `{}` but can be documented only once. Consider renaming \
                     or marking one of the targets as `doc = false`.",
                    target.crate_name(),
                    prev,
                    package
                );
            }
            names.push(target.crate_name());
        }
    }

    let open_kind = if options.open_result {
        Some(options.compile_opts.build_config.single_requested_kind()?)
    } else {
        None
    };

    // Before compiling, we need to make sure that if there were any previous docs
    // already compiled, they were compiled with the same Rustc version that we're currently
    // using. Otherways we must remove the `doc/` folder and compile again.
    //
    // This is important because the .js/.html&.css files that are generated by Rustc don't have
    // any versioning. Therefore, we can fall in weird bugs and behaviours if we mix different
    // compiler versions of these js/.html&.css files.
    check_rustdoc_appropiate_versioning(ws, &target_data)?;

    let compilation = ops::compile(ws, &options.compile_opts)?;

    if let Some(kind) = open_kind {
        let name = match names.first() {
            Some(s) => s.to_string(),
            None => return Ok(()),
        };
        let path = compilation.root_output[&kind]
            .with_file_name("doc")
            .join(&name)
            .join("index.html");
        if path.exists() {
            let mut shell = ws.config().shell();
            shell.status("Opening", path.display())?;
            open_docs(&path, &mut shell)?;
        }
    }

    Ok(())
}

fn open_docs(path: &Path, shell: &mut Shell) -> CargoResult<()> {
    match std::env::var_os("BROWSER") {
        Some(browser) => {
            if let Err(e) = Command::new(&browser).arg(path).status() {
                shell.warn(format!(
                    "Couldn't open docs with {}: {}",
                    browser.to_string_lossy(),
                    e
                ))?;
            }
        }
        None => {
            if let Err(e) = opener::open(&path) {
                let e = e.into();
                crate::display_warning_with_error("couldn't open docs", &e, shell);
            }
        }
    };

    Ok(())
}

/// This function checks whether the latest version of `Rustc` used to compile this
/// `Workspace`'s docs was the same as the one is being used in this `cargo doc` call.
///
/// In case it's not, it takes care of removig the `doc/` folder as well as overwriting
/// the rustdoc fingerprint info in order to guarantee that we won't end up with mixed
/// versions of the `js/html/css` files that `Rustc` autogenerates (which btw, do not have)
/// any versioning.
fn check_rustdoc_appropiate_versioning(
    ws: &Workspace<'_>,
    target_data: &RustcTargetData,
) -> anyhow::Result<()> {
    let actual_rustdoc_target_data =
        RustDocTargetData::with_actual_rustc_version(&target_data.rustc.verbose_version);
    let mut rustdoc_fingerprint_file = match File::open(RustDocTargetData::path_to_fingerprint(ws))
    {
        Ok(file) => file,
        // If the file does not exist, create it with the actual `Rustc` version
        // and try to delete the `doc/` folder.
        //
        // This is weird, but if someone deletes the fingerprint and compiled the docs
        // of the target workspace with a previous `Rustc` version, we would fall under
        // the same problem.
        Err(_) => {
            // Check if `doc/` folder exists and remove it. Otherways, simply create
            // `.rustdoc_fingerprint.json` file.
            remove_doc_directory(ws)?;
            let rustdoc_fingerprint_file =
                File::create(RustDocTargetData::path_to_fingerprint(ws))?;
            // We write the actual `Rustc` version to it so that we just need to compile it straight
            // since there's no `doc/` folder to remove.
            to_writer(&rustdoc_fingerprint_file, &actual_rustdoc_target_data)?;
            rustdoc_fingerprint_file
        }
    };

    let previous_rustdoc_target_data = RustDocTargetData::from_file(&mut rustdoc_fingerprint_file)?;
    // Check if rustc_version matches the one we just used. Otherways,
    // re-write it and delete the Â´doc/` folder (if exists).
    if previous_rustdoc_target_data.rustc_verbose_version != target_data.rustc.verbose_version {
        remove_doc_directory(ws)?;
        // Remove `rustdoc_fingerprint_file` contents and write the new version used
        // to compile the docs.
        rustdoc_fingerprint_file.set_len(0)?;
        to_writer(&rustdoc_fingerprint_file, &actual_rustdoc_target_data)?;
    };
    Ok(())
}

/// Tries to remove the Workspace's `target/doc/` directory wit all of it's contents
/// returning an error if it's not possible.
fn remove_doc_directory(ws: &Workspace<'_>) -> std::io::Result<()> {
    let doc_path = &ws.root().join("target").join("doc");
    if doc_path.exists() {
        // Try to remove the `doc/` folder if exists.
        // XXX: What should we do if the op fails?
        std::fs::remove_dir_all(doc_path)
    } else {
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RustDocTargetData {
    rustc_verbose_version: String,
}

impl RustDocTargetData {
    pub fn with_actual_rustc_version(rustc_verbose_version: &str) -> Self {
        Self {
            rustc_verbose_version: rustc_verbose_version.to_string(),
        }
    }

    pub fn path_to_fingerprint(ws: &Workspace<'_>) -> PathBuf {
        ws.root().join("target").join(".rustdoc_fingerprint.json")
    }

    pub fn from_file(file: &mut File) -> anyhow::Result<Self> {
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        let rustdoc_target_data: Self = from_str(&contents)?;
        Ok(rustdoc_target_data)
    }
}
